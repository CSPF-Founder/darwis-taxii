//! Malware SDO
//!
//! Malware is a type of TTP that represents malicious code.

use crate::core::common::CommonProperties;
use crate::core::error::{Error, Result};
use crate::core::id::Identifier;
use crate::core::kill_chain_phase::KillChainPhase;
use crate::core::timestamp::Timestamp;
use crate::impl_sdo_traits;
use crate::validation::{Constrained, check_conditional_required, check_timestamp_order};
use crate::vocab::{MalwareCapability, MalwareType};
use serde::{Deserialize, Serialize};

/// Malware STIX Domain Object.
///
/// Malware is a type of TTP that represents malicious code. It is primarily
/// used to characterize malware samples.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Malware {
    /// The type property identifies the type of STIX Object.
    #[serde(rename = "type")]
    pub type_: String,

    /// The id property uniquely identifies this object.
    pub id: Identifier,

    /// Common properties shared by all SDOs.
    #[serde(flatten)]
    pub common: CommonProperties,

    /// A name used to identify the Malware.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// A description that provides more details about the Malware.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// The types of malware.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub malware_types: Vec<MalwareType>,

    /// Whether the object represents a malware sample/family.
    pub is_family: bool,

    /// Alternative names for this Malware.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub aliases: Vec<String>,

    /// The kill chain phases for this Malware.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub kill_chain_phases: Vec<KillChainPhase>,

    /// The time the malware was first seen.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub first_seen: Option<Timestamp>,

    /// The time the malware was last seen.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_seen: Option<Timestamp>,

    /// The operating systems the malware targets.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub operating_system_refs: Vec<Identifier>,

    /// The processor architectures the malware targets.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub architecture_execution_envs: Vec<String>,

    /// The languages the malware supports.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub implementation_languages: Vec<String>,

    /// The capabilities of the malware.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub capabilities: Vec<MalwareCapability>,

    /// References to samples of this malware.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub sample_refs: Vec<Identifier>,
}

impl Malware {
    /// The STIX type identifier for Malware.
    pub const TYPE: &'static str = "malware";

    /// Create a new MalwareBuilder.
    pub fn builder() -> MalwareBuilder {
        MalwareBuilder::new()
    }
}

impl_sdo_traits!(Malware, "malware");

impl Constrained for Malware {
    /// Validate Malware constraints.
    ///
    /// - `last_seen` must be >= `first_seen`
    /// - If `is_family` is true, `name` is required
    fn validate_constraints(&self) -> Result<()> {
        // Timestamp ordering
        check_timestamp_order(
            self.first_seen.as_ref(),
            self.last_seen.as_ref(),
            "first_seen",
            "last_seen",
        )?;

        // is_family requires name
        check_conditional_required(
            self.is_family,
            "is_family is true",
            "name",
            self.name.is_some(),
        )?;

        Ok(())
    }
}

/// Builder for creating Malware objects.
#[derive(Debug, Default)]
pub struct MalwareBuilder {
    name: Option<String>,
    description: Option<String>,
    malware_types: Vec<MalwareType>,
    is_family: bool,
    aliases: Vec<String>,
    kill_chain_phases: Vec<KillChainPhase>,
    first_seen: Option<Timestamp>,
    last_seen: Option<Timestamp>,
    operating_system_refs: Vec<Identifier>,
    capabilities: Vec<MalwareCapability>,
    architecture_execution_envs: Vec<String>,
    implementation_languages: Vec<String>,
    sample_refs: Vec<Identifier>,
    common: CommonProperties,
}

// Implement common builder methods
crate::impl_common_builder_methods!(MalwareBuilder);

impl MalwareBuilder {
    /// Create a new builder.
    pub fn new() -> Self {
        Self::default()
    }

    /// Set the name.
    pub fn name(mut self, name: impl Into<String>) -> Self {
        self.name = Some(name.into());
        self
    }

    /// Set the description.
    pub fn description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Add a malware type.
    pub fn malware_type(mut self, malware_type: MalwareType) -> Self {
        self.malware_types.push(malware_type);
        self
    }

    /// Set whether this is a malware family (required).
    pub fn is_family(mut self, is_family: bool) -> Self {
        self.is_family = is_family;
        self
    }

    /// Add an alias.
    pub fn alias(mut self, alias: impl Into<String>) -> Self {
        self.aliases.push(alias.into());
        self
    }

    /// Add a kill chain phase.
    pub fn kill_chain_phase(mut self, phase: KillChainPhase) -> Self {
        self.kill_chain_phases.push(phase);
        self
    }

    /// Set the first seen timestamp.
    pub fn first_seen(mut self, first_seen: Timestamp) -> Self {
        self.first_seen = Some(first_seen);
        self
    }

    /// Set the last seen timestamp.
    pub fn last_seen(mut self, last_seen: Timestamp) -> Self {
        self.last_seen = Some(last_seen);
        self
    }

    /// Add a capability.
    pub fn capability(mut self, capability: MalwareCapability) -> Self {
        self.capabilities.push(capability);
        self
    }

    /// Add an architecture execution environment.
    pub fn architecture(mut self, arch: impl Into<String>) -> Self {
        self.architecture_execution_envs.push(arch.into());
        self
    }

    /// Add an implementation language.
    pub fn implementation_language(mut self, lang: impl Into<String>) -> Self {
        self.implementation_languages.push(lang.into());
        self
    }

    /// Add an operating system reference.
    pub fn operating_system_ref(mut self, ref_: Identifier) -> Self {
        self.operating_system_refs.push(ref_);
        self
    }

    /// Add a sample reference.
    pub fn sample_ref(mut self, ref_: Identifier) -> Self {
        self.sample_refs.push(ref_);
        self
    }

    /// Set the created_by_ref.
    pub fn created_by_ref(mut self, identity_ref: Identifier) -> Self {
        self.common.created_by_ref = Some(identity_ref);
        self
    }

    /// Add a label.
    pub fn label(mut self, label: impl Into<String>) -> Self {
        self.common.labels.push(label.into());
        self
    }

    /// Set confidence level.
    pub fn confidence(mut self, confidence: u8) -> Self {
        self.common.confidence = Some(confidence.min(100));
        self
    }

    /// Build the Malware.
    pub fn build(self) -> Result<Malware> {
        // Validate: either name or malware_types must be present
        if self.name.is_none() && self.malware_types.is_empty() {
            return Err(Error::AtLeastOneRequired(vec![
                "name".to_string(),
                "malware_types".to_string(),
            ]));
        }

        let malware = Malware {
            type_: Malware::TYPE.to_string(),
            id: Identifier::new(Malware::TYPE)?,
            common: self.common,
            name: self.name,
            description: self.description,
            malware_types: self.malware_types,
            is_family: self.is_family,
            aliases: self.aliases,
            kill_chain_phases: self.kill_chain_phases,
            first_seen: self.first_seen,
            last_seen: self.last_seen,
            operating_system_refs: self.operating_system_refs,
            architecture_execution_envs: self.architecture_execution_envs,
            implementation_languages: self.implementation_languages,
            capabilities: self.capabilities,
            sample_refs: self.sample_refs,
        };

        // Validate constraints
        malware.validate_constraints()?;

        Ok(malware)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_malware() {
        let malware = Malware::builder()
            .name("WannaCry")
            .malware_type(MalwareType::Ransomware)
            .is_family(true)
            .build()
            .unwrap();

        assert_eq!(malware.name, Some("WannaCry".to_string()));
        assert_eq!(malware.type_, "malware");
        assert!(malware.is_family);
    }

    #[test]
    fn test_malware_with_capabilities() {
        let malware = Malware::builder()
            .name("TestMalware")
            .malware_type(MalwareType::Trojan)
            .capability(MalwareCapability::ExfiltratesData)
            .capability(MalwareCapability::CommunicatesWithC2)
            .build()
            .unwrap();

        assert_eq!(malware.capabilities.len(), 2);
    }

    #[test]
    fn test_serialization() {
        let malware = Malware::builder()
            .name("Test Malware")
            .malware_type(MalwareType::Bot)
            .is_family(false)
            .build()
            .unwrap();

        let json = serde_json::to_string(&malware).unwrap();
        let parsed: Malware = serde_json::from_str(&json).unwrap();
        assert_eq!(malware.name, parsed.name);
    }

    #[test]
    fn test_missing_name_and_types() {
        let result = Malware::builder().is_family(true).build();
        assert!(result.is_err());
    }
}
