//! Malware Analysis SDO (STIX 2.1)
//!
//! Malware Analysis captures metadata about a malware analysis run.

use crate::core::common::CommonProperties;
use crate::core::error::{Error, Result};
use crate::core::id::Identifier;
use crate::core::timestamp::Timestamp;
use crate::impl_sdo_traits;
use crate::validation::{Constrained, check_at_least_one};
use crate::vocab::MalwareAnalysisResult;
use serde::{Deserialize, Serialize};

/// Malware Analysis STIX Domain Object.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MalwareAnalysis {
    #[serde(rename = "type")]
    pub type_: String,
    pub id: Identifier,
    #[serde(flatten)]
    pub common: CommonProperties,
    pub product: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub host_vm_ref: Option<Identifier>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub operating_system_ref: Option<Identifier>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub installed_software_refs: Option<Vec<Identifier>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub configuration_version: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub modules: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis_engine_version: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis_definition_version: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub submitted: Option<Timestamp>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis_started: Option<Timestamp>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis_ended: Option<Timestamp>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result_name: Option<String>,
    /// The result of the analysis.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<MalwareAnalysisResult>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub analysis_sco_refs: Vec<Identifier>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sample_ref: Option<Identifier>,
}

impl MalwareAnalysis {
    pub const TYPE: &'static str = "malware-analysis";

    pub fn builder() -> MalwareAnalysisBuilder {
        MalwareAnalysisBuilder::new()
    }
}

impl_sdo_traits!(MalwareAnalysis, "malware-analysis");

impl Constrained for MalwareAnalysis {
    /// Validate MalwareAnalysis constraints.
    ///
    /// - At least one of `result` or `analysis_sco_refs` must be present
    fn validate_constraints(&self) -> Result<()> {
        let mut present = Vec::new();
        if self.result.is_some() {
            present.push("result");
        }
        if !self.analysis_sco_refs.is_empty() {
            present.push("analysis_sco_refs");
        }

        check_at_least_one(&present, &["result", "analysis_sco_refs"])
    }
}

#[derive(Debug, Default)]
pub struct MalwareAnalysisBuilder {
    product: Option<String>,
    version: Option<String>,
    result_name: Option<String>,
    result: Option<MalwareAnalysisResult>,
    submitted: Option<Timestamp>,
    analysis_started: Option<Timestamp>,
    analysis_ended: Option<Timestamp>,
    sample_ref: Option<Identifier>,
    analysis_sco_refs: Vec<Identifier>,
    common: CommonProperties,
}

// Implement common builder methods
crate::impl_common_builder_methods!(MalwareAnalysisBuilder);

impl MalwareAnalysisBuilder {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn product(mut self, product: impl Into<String>) -> Self {
        self.product = Some(product.into());
        self
    }

    pub fn version(mut self, version: impl Into<String>) -> Self {
        self.version = Some(version.into());
        self
    }

    pub fn result_name(mut self, name: impl Into<String>) -> Self {
        self.result_name = Some(name.into());
        self
    }

    pub fn result(mut self, result: MalwareAnalysisResult) -> Self {
        self.result = Some(result);
        self
    }

    pub fn submitted(mut self, submitted: Timestamp) -> Self {
        self.submitted = Some(submitted);
        self
    }

    pub fn analysis_started(mut self, started: Timestamp) -> Self {
        self.analysis_started = Some(started);
        self
    }

    pub fn analysis_ended(mut self, ended: Timestamp) -> Self {
        self.analysis_ended = Some(ended);
        self
    }

    pub fn sample_ref(mut self, sample_ref: Identifier) -> Self {
        self.sample_ref = Some(sample_ref);
        self
    }

    pub fn analysis_sco_ref(mut self, ref_: Identifier) -> Self {
        self.analysis_sco_refs.push(ref_);
        self
    }

    pub fn created_by_ref(mut self, identity_ref: Identifier) -> Self {
        self.common.created_by_ref = Some(identity_ref);
        self
    }

    /// Add a label.
    pub fn label(mut self, label: impl Into<String>) -> Self {
        self.common.labels.push(label.into());
        self
    }

    /// Set confidence level.
    pub fn confidence(mut self, confidence: u8) -> Self {
        self.common.confidence = Some(confidence.min(100));
        self
    }

    pub fn build(self) -> Result<MalwareAnalysis> {
        let product = self
            .product
            .ok_or_else(|| Error::missing_property("product"))?;

        let analysis = MalwareAnalysis {
            type_: MalwareAnalysis::TYPE.to_string(),
            id: Identifier::new(MalwareAnalysis::TYPE)?,
            common: self.common,
            product,
            version: self.version,
            host_vm_ref: None,
            operating_system_ref: None,
            installed_software_refs: None,
            configuration_version: None,
            modules: Vec::new(),
            analysis_engine_version: None,
            analysis_definition_version: None,
            submitted: self.submitted,
            analysis_started: self.analysis_started,
            analysis_ended: self.analysis_ended,
            result_name: self.result_name,
            result: self.result,
            analysis_sco_refs: self.analysis_sco_refs,
            sample_ref: self.sample_ref,
        };

        // Validate constraints
        analysis.validate_constraints()?;

        Ok(analysis)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_malware_analysis() {
        let analysis = MalwareAnalysis::builder()
            .product("Cuckoo Sandbox")
            .version("2.0.7")
            .result(MalwareAnalysisResult::Malicious)
            .build()
            .unwrap();

        assert_eq!(analysis.type_, "malware-analysis");
        assert_eq!(analysis.result, Some(MalwareAnalysisResult::Malicious));
    }
}
